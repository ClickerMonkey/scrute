{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///scrute.min.js","webpack:///webpack/bootstrap 583ce262d2bc2d4b6350","webpack:///./src/handler.ts","webpack:///./src/observe.ts","webpack:///./src/watch.ts","webpack:///./src/unobserve.ts","webpack:///./src/computed.ts","webpack:///./src/Constants.ts","webpack:///./src/Node.ts","webpack:///./src/Dependency.ts","webpack:///./src/Watcher.ts","webpack:///./src/Link.ts","webpack:///./src/Observer.ts","webpack:///./src/index.ts"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","handleWatching","target","prop","val","obs","dep","liveWatchers","forEach","watcher","Link_Link","create","isObservable","isObserved","observe","parent","handleArrayIteration","length","apply","arguments","handleArrayChange","copy","slice","result","max","Math","deepNotified","notify","remove","input","_a","_b","PROPERTY","proxy","Proxy","revocable","handler","value","Observer_Observer","revoke","writable","watch","expr","_c","immediate","_d","deep","Watcher_Watcher","update","unobserve","destroy","computed","dirty","ARRAY_CHANGES","pop","push","shift","unshift","reverse","splice","sort","ARRAY_ITERATIONS","concat","every","fill","filter","find","findIndex","includes","indexOf","join","lastIndexOf","map","reduce","reduceRight","some","Node","next","prev","iterator","curr","index","insertAfter","last","isEmpty","head","Dependency_Dependency","Dependency","observer","links","notifyParent","link","Watcher","expression","paused","evaluating","isWatching","off","onResult","pause","resume","Link","dependency","watcherNode","dependencyNode","existing","_reciever","Array","set","deleteProperty","Observer","deps"],"mappings":"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","file":"scrute.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"scrute\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"scrute\"] = factory();\n\telse\n\t\troot[\"scrute\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"scrute\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"scrute\"] = factory();\n\telse\n\t\troot[\"scrute\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// CONCATENATED MODULE: ./src/Constants.ts\n/**\r\n * The hidden property which stores the reference to the Observer for an object.\r\n */\r\nvar PROPERTY = '$obs';\r\n/**\r\n * This is a map of array functions which modify the contents of an array. When\r\n * this happens the observed array is checked for referential and length changes.\r\n */\r\nvar ARRAY_CHANGES = {\r\n    'pop': 1,\r\n    'push': 1,\r\n    'shift': 1,\r\n    'unshift': 1,\r\n    'reverse': 1,\r\n    'splice': 1,\r\n    'sort': 1,\r\n};\r\n/**\r\n * This is a map of array functions which can return different results when the\r\n * array is modified with the above functions. When these functions are called\r\n * the watch function observes all items in the array and it's length.\r\n */\r\nvar ARRAY_ITERATIONS = {\r\n    'concat': 1,\r\n    'every': 1,\r\n    'fill': 1,\r\n    'filter': 1,\r\n    'find': 1,\r\n    'findIndex': 1,\r\n    'forEach': 1,\r\n    'includes': 1,\r\n    'indexOf': 1,\r\n    'join': 1,\r\n    'lastIndexOf': 1,\r\n    'map': 1,\r\n    'reduce': 1,\r\n    'reduceRight': 1,\r\n    'slice': 1,\r\n    'some': 1,\r\n};\r\n\n// CONCATENATED MODULE: ./src/Node.ts\n/**\r\n * A node in a doubly-linked list. The functions in this class are mostly\r\n * intended for use by the head node. A default head node points to itself and\r\n * has a null value. A node always has a next or previous node reference.\r\n */\r\nvar Node = /** @class */ (function () {\r\n    /**\r\n     * Creates a new node given a value.\r\n     *\r\n     * @param value The value for the node.\r\n     */\r\n    function Node(value) {\r\n        this.value = value;\r\n        this.next = this.prev = this;\r\n    }\r\n    /**\r\n     * Iterates over the nodes in the linked list and returns the number of nodes\r\n     * in the list.\r\n     *\r\n     * @param iterator The function to call with the value of the node, the\r\n     *    reference to the node (useful for removing the value from the list),\r\n     *    and the index of the value in the list starting at the next node.\r\n     */\r\n    Node.prototype.forEach = function (iterator) {\r\n        var curr = this.next;\r\n        var index = 0;\r\n        while (curr !== this) {\r\n            var next = curr.next;\r\n            iterator(curr.value, curr, index);\r\n            curr = next;\r\n            index++;\r\n        }\r\n        return index;\r\n    };\r\n    /**\r\n     * Inserts this Node after the given node.\r\n     *\r\n     * @param prev The node to insert this Node after.\r\n     */\r\n    Node.prototype.insertAfter = function (prev) {\r\n        this.next = prev.next;\r\n        this.prev = prev;\r\n        this.prev.next = this.next.prev = this;\r\n    };\r\n    /**\r\n     * If this is the head of a list, this function adds a node to the very end\r\n     * of the list. This is also equivalent to adding the given node directly\r\n     * before this node.\r\n     *\r\n     * @param last The node to insert at the end of the list / before this node.\r\n     */\r\n    Node.prototype.push = function (last) {\r\n        last.insertAfter(this.prev);\r\n    };\r\n    /**\r\n     * If this Node is in a list, it removes itself from the list.\r\n     */\r\n    Node.prototype.remove = function () {\r\n        if (!this.isEmpty()) {\r\n            this.next.prev = this.prev;\r\n            this.prev.next = this.next;\r\n            this.prev = this.next = this;\r\n        }\r\n    };\r\n    /**\r\n     * Returns whether the list this node is in is empty.\r\n     */\r\n    Node.prototype.isEmpty = function () {\r\n        return this.next === this;\r\n    };\r\n    /**\r\n     * Returns a new node for the head of the list.\r\n     */\r\n    Node.head = function () {\r\n        return new Node(null);\r\n    };\r\n    return Node;\r\n}());\r\n\r\n\n// CONCATENATED MODULE: ./src/Dependency.ts\n\r\n/**\r\n * A dependency is a property of an object or an item in an array.\r\n */\r\nvar Dependency_Dependency = /** @class */ (function () {\r\n    /**\r\n     * Creates a new Dependency.\r\n     *\r\n     * @param observer The observer for the object.\r\n     */\r\n    function Dependency(observer) {\r\n        this.observer = observer;\r\n        this.links = Node.head();\r\n    }\r\n    /**\r\n     * Notifies all observing watchers that this dependency has changed. If any\r\n     * of the watchers are watching for deep (sub) changes the parent dependency\r\n     * is notified.\r\n     *\r\n     * @param notifyParent If a deep watcher is listening on this dependency,\r\n     *    should we notify the parent of the observer?\r\n     * @returns True if a deep watcher was notified.\r\n     */\r\n    Dependency.prototype.notify = function (notifyParent) {\r\n        if (notifyParent === void 0) { notifyParent = false; }\r\n        var deep = false;\r\n        this.links.forEach(function (link) {\r\n            link.watcher.notify();\r\n            deep = deep || link.watcher.deep;\r\n        });\r\n        if (notifyParent && deep && this.observer.parent) {\r\n            this.observer.parent.notify(notifyParent);\r\n        }\r\n        return deep;\r\n    };\r\n    /**\r\n     * Destroys the depdendency removing it from all watchers.\r\n     */\r\n    Dependency.prototype.destroy = function () {\r\n        this.links.forEach(function (link) { return link.remove(); });\r\n    };\r\n    return Dependency;\r\n}());\r\n\r\n\n// CONCATENATED MODULE: ./src/Watcher.ts\n\r\n/**\r\n * An array of watcher functions which are currently executing.\r\n */\r\nvar liveWatchers = [];\r\n/**\r\n * A class which holds a user supplied function and list of observed\r\n * depdendencies it references. When any of those dependencies change a watcher\r\n * is notified.\r\n */\r\nvar Watcher_Watcher = /** @class */ (function () {\r\n    /**\r\n     * Creates a new Watcher given an expression, if it's immediate, and if the\r\n     * watches are deep.\r\n     */\r\n    function Watcher(expression, immediate, deep) {\r\n        if (immediate === void 0) { immediate = true; }\r\n        if (deep === void 0) { deep = false; }\r\n        this.expression = expression;\r\n        this.immediate = immediate;\r\n        this.deep = deep;\r\n        this.dirty = false;\r\n        this.paused = false;\r\n        this.evaluating = false;\r\n        this.links = Node.head();\r\n    }\r\n    /**\r\n     * Determines whether the watch function is currently observing anything for\r\n     * changes.\r\n     */\r\n    Watcher.prototype.isWatching = function () {\r\n        return !this.links.isEmpty();\r\n    };\r\n    /**\r\n     * Notifies the watcher that a dependency has changed.\r\n     */\r\n    Watcher.prototype.notify = function () {\r\n        if (this.evaluating) {\r\n            return;\r\n        }\r\n        this.dirty = true;\r\n        if (this.immediate) {\r\n            this.update();\r\n        }\r\n    };\r\n    /**\r\n     * Executes the function and gathers a new list of dependencies.\r\n     */\r\n    Watcher.prototype.update = function () {\r\n        this.evaluating = true;\r\n        this.off();\r\n        liveWatchers.push(this);\r\n        try {\r\n            this.result = this.expression();\r\n        }\r\n        finally {\r\n            liveWatchers.pop();\r\n            this.dirty = false;\r\n            if (this.onResult) {\r\n                try {\r\n                    this.onResult();\r\n                }\r\n                finally {\r\n                    this.evaluating = false;\r\n                }\r\n            }\r\n            this.evaluating = false;\r\n        }\r\n    };\r\n    /**\r\n     * Stops watching for changes.\r\n     */\r\n    Watcher.prototype.off = function () {\r\n        this.links.forEach(function (link) { return link.remove(); });\r\n    };\r\n    /**\r\n     * Stops watching for changes and marks the watcher as paused.\r\n     */\r\n    Watcher.prototype.pause = function () {\r\n        if (!this.paused) {\r\n            this.off();\r\n            this.paused = true;\r\n        }\r\n    };\r\n    /**\r\n     * Resumes watching for changes if the watcher was paused.\r\n     */\r\n    Watcher.prototype.resume = function () {\r\n        if (this.paused) {\r\n            this.update();\r\n            this.paused = false;\r\n        }\r\n    };\r\n    return Watcher;\r\n}());\r\n\r\n\n// CONCATENATED MODULE: ./src/Link.ts\n\r\n/**\r\n * A relationship between a Watcher and Dependency which stores both links so\r\n * the lists stored in the watcher and dependency can both be removed from\r\n * instantly.\r\n */\r\nvar Link_Link = /** @class */ (function () {\r\n    /**\r\n     * Creates a new Link given the Watcher and Dependency.\r\n     */\r\n    function Link(watcher, dependency) {\r\n        this.watcher = watcher;\r\n        this.dependency = dependency;\r\n        this.watcherNode = new Node(this);\r\n        this.dependencyNode = new Node(this);\r\n    }\r\n    /**\r\n     * Removes the relationship between the Watcher and Dependency.\r\n     */\r\n    Link.prototype.remove = function () {\r\n        this.watcherNode.remove();\r\n        this.dependencyNode.remove();\r\n    };\r\n    /**\r\n     * Creates a link between the given Watcher and Dependency. If a link already\r\n     * exists, then this function has no effect. If a link does not exist, one is\r\n     * created and added to both the dependency and watcher lists. A link\r\n     * reference is always returned.\r\n     */\r\n    Link.create = function (watcher, dependency) {\r\n        var existing = null;\r\n        dependency.links.forEach(function (link) { return existing = (link.watcher === watcher ? link : existing); });\r\n        if (!existing) {\r\n            existing = new Link(watcher, dependency);\r\n            dependency.links.push(existing.dependencyNode);\r\n            watcher.links.push(existing.watcherNode);\r\n        }\r\n        return existing;\r\n    };\r\n    return Link;\r\n}());\r\n\r\n\n// CONCATENATED MODULE: ./src/handler.ts\n\r\n\r\n\r\n\r\n/**\r\n * The handler to pass to the Proxy constructor.\r\n */\r\nvar handler = {\r\n    /**\r\n     * Intercepts the property getting so any watch functions can gather its list\r\n     * of dependencies.\r\n     */\r\n    get: function (target, prop, _reciever) {\r\n        var val = target[prop];\r\n        if (prop === PROPERTY) {\r\n            return val;\r\n        }\r\n        var obs = target[PROPERTY];\r\n        if (typeof val === 'function') {\r\n            if (target instanceof Array) {\r\n                if (prop in ARRAY_CHANGES) {\r\n                    return handleArrayChange(target, val, obs);\r\n                }\r\n                if (prop in ARRAY_ITERATIONS) {\r\n                    return handleArrayIteration(target, val, obs);\r\n                }\r\n            }\r\n            return val;\r\n        }\r\n        return handleWatching(target, prop, val, obs);\r\n    },\r\n    /**\r\n     * Intercepts the property setting so all dependent watchers are notified,\r\n     */\r\n    set: function (target, prop, value, _reciever) {\r\n        if (value !== target[prop]) {\r\n            target[prop] = value;\r\n            var obs = target[PROPERTY];\r\n            obs.notify(prop, true);\r\n        }\r\n        return true;\r\n    },\r\n    /**\r\n     * Intercepts the property delete operator so all dependent watchers no longer\r\n     * listen to changes.\r\n     */\r\n    deleteProperty: function (target, prop) {\r\n        var obs = target[PROPERTY];\r\n        obs.remove(prop);\r\n        return true;\r\n    }\r\n};\r\n/**\r\n * If a property on an object contains an observable object/array which is not\r\n * yet being observered - it is replaced with a proxy. The value of the property\r\n * is returned.\r\n */\r\nfunction handleWatching(target, prop, val, obs) {\r\n    var dep = obs.dep(prop);\r\n    liveWatchers.forEach(function (watcher) { return Link_Link.create(watcher, dep); });\r\n    if (isObservable(val) && !isObserved(val)) {\r\n        target[prop] = val = observe(val, { parent: dep });\r\n    }\r\n    return val;\r\n}\r\n/**\r\n * Returns a function which ensures when its called that all items and the\r\n * length of the array is watched by any live watchers.\r\n */\r\nfunction handleArrayIteration(target, val, obs) {\r\n    return function () {\r\n        var length = target.length;\r\n        for (var i = 0; i < length; i++) {\r\n            handleWatching(target, i, target[i], obs);\r\n        }\r\n        handleWatching(target, 'length', target.length, obs);\r\n        return val.apply(target, arguments);\r\n    };\r\n}\r\n/**\r\n * Returns a function which notifies any watched functions of changes after a\r\n * mutating array operation is executed.\r\n */\r\nfunction handleArrayChange(target, val, obs) {\r\n    return function () {\r\n        var copy = target.slice();\r\n        var result = val.apply(target, arguments);\r\n        var max = Math.max(copy.length, target.length);\r\n        var deepNotified = false;\r\n        for (var i = 0; i < max; i++) {\r\n            if (copy[i] !== target[i]) {\r\n                deepNotified = deepNotified || obs.notify(i);\r\n            }\r\n            if (i >= target.length) {\r\n                obs.remove(i);\r\n            }\r\n        }\r\n        if (target.length !== copy.length) {\r\n            deepNotified = deepNotified || obs.notify('length');\r\n        }\r\n        if (deepNotified && obs.parent) {\r\n            obs.parent.notify(true);\r\n        }\r\n        return result;\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: ./src/observe.ts\n\r\n\r\n\r\n/**\r\n * Observes the object/array if is not yet observed. An observed object is one\r\n * that can be used in watch functions and will trigger then when referenced\r\n * values in the observed object changes.\r\n *\r\n * @param input The object/array to observe for changes.\r\n * @returns The reference to the object/array or the Proxy if it is observable\r\n *    and has not yet been observed.\r\n */\r\nfunction observe(input, _a) {\r\n    var _b = (_a === void 0 ? {} : _a).parent, parent = _b === void 0 ? null : _b;\r\n    if (isObservable(input)) {\r\n        if (!input[PROPERTY]) {\r\n            var proxy = Proxy.revocable(input, handler);\r\n            input = proxy.proxy;\r\n            Object.defineProperty(input, PROPERTY, {\r\n                value: new Observer_Observer(proxy.revoke, parent),\r\n                writable: false,\r\n                configurable: true,\r\n                enumerable: false\r\n            });\r\n        }\r\n    }\r\n    return input;\r\n}\r\n/**\r\n * Determines whether the given input can be observed.\r\n *\r\n * @param input The input to test.\r\n */\r\nfunction isObservable(input) {\r\n    return !!(typeof input === 'object' && input !== null);\r\n}\r\n/**\r\n * Determines whether the given input is currently being observed.\r\n *\r\n * @param input The input to check for observation.\r\n */\r\nfunction isObserved(input) {\r\n    return !!(typeof input === 'object' && input !== null && input[PROPERTY]);\r\n}\r\n\n// CONCATENATED MODULE: ./src/Observer.ts\n\r\n\r\n\r\n/**\r\n * An observer is for an object/array and keeps track of all watched properties.\r\n * If the observer belongs to a sub-object on an observed object then it has a\r\n * parent. This parent reference is needed for deeply watched objects.\r\n */\r\nvar Observer_Observer = /** @class */ (function () {\r\n    /**\r\n     * Creates a new Observer.\r\n     *\r\n     * @param parent An optional parent dependency.\r\n     */\r\n    function Observer(revoke, parent) {\r\n        if (parent === void 0) { parent = null; }\r\n        this.revoke = revoke;\r\n        this.parent = parent;\r\n        this.deps = Object.create(null);\r\n    }\r\n    /**\r\n     * Returns a Dependency for the given property and creates it if it doesn't\r\n     * exist already.\r\n     *\r\n     * @param prop The name of the property or the index of the array element.\r\n     */\r\n    Observer.prototype.dep = function (prop) {\r\n        var dep = this.deps[prop];\r\n        if (!dep) {\r\n            this.deps[prop] = dep = new Dependency_Dependency(this);\r\n        }\r\n        return dep;\r\n    };\r\n    /**\r\n     * If the given property or array element is being watched, all watchers will\r\n     * be notified.\r\n     *\r\n     * @param prop The name of the property or the index of the array element to\r\n     *    notify of changes.\r\n     * @param notifyParent If a deep watcher is listening on this dependency,\r\n     *    should we notify the parent of the observer?\r\n     * @returns True if a deep watcher was notified.\r\n     */\r\n    Observer.prototype.notify = function (prop, notifyParent) {\r\n        if (notifyParent === void 0) { notifyParent = false; }\r\n        var deps = this.deps;\r\n        if (prop in deps) {\r\n            return deps[prop].notify(notifyParent);\r\n        }\r\n        else if (notifyParent && this.parent) {\r\n            this.parent.notify(notifyParent);\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Removes the given property or array element so it's no longer observed for\r\n     * changes.\r\n     *\r\n     * @param prop The name of the property or the index of the array element to\r\n     *    cease watching on.\r\n     */\r\n    Observer.prototype.remove = function (prop) {\r\n        var deps = this.deps;\r\n        if (prop in deps) {\r\n            deps[prop].destroy();\r\n            delete deps[prop];\r\n        }\r\n    };\r\n    /**\r\n     * Destroys this observer by destroying all dependents.\r\n     *\r\n     * @param target The object which holds this observer.\r\n     * @param deep If any descendant objects should be destroyed as well.\r\n     * @param revoke If the proxy should be revoked, making the object unusable.\r\n     */\r\n    Observer.prototype.destroy = function (target, deep, revoke) {\r\n        if (deep === void 0) { deep = false; }\r\n        if (revoke === void 0) { revoke = true; }\r\n        var deps = this.deps;\r\n        for (var prop in deps) {\r\n            deps[prop].destroy();\r\n            delete deps[prop];\r\n            if (deep) {\r\n                var value = target[prop];\r\n                if (isObserved(value)) {\r\n                    var obs = value[PROPERTY];\r\n                    obs.destroy(value, deep, revoke);\r\n                }\r\n            }\r\n        }\r\n        if (revoke) {\r\n            this.revoke();\r\n        }\r\n    };\r\n    return Observer;\r\n}());\r\n\r\n\n// CONCATENATED MODULE: ./src/watch.ts\n\r\n/**\r\n * Given a function to execute, any observed objects/arrays which are referenced\r\n * in that function are tracked. If they change the given function will execute\r\n * again and a new list of dependencies is generated. A Watcher instance is\r\n * returned which can be used to pause, resume, or stop watching for changes.\r\n *\r\n * @param expr The function to execute when any referenced observed values change.\r\n * @param immediate If the function should executed as soon as a dependent value\r\n *    changes (true), or simply mark the returned Watcher instance as dirty (false).\r\n * @param deep If true, not only does the function execute when referenced\r\n *    values change, but also nested values.\r\n * @returns A new instance of Watcher.\r\n */\r\nfunction watch(expr, _a) {\r\n    var _b = _a === void 0 ? {} : _a, _c = _b.immediate, immediate = _c === void 0 ? true : _c, _d = _b.deep, deep = _d === void 0 ? false : _d;\r\n    var watcher = new Watcher_Watcher(expr, immediate, deep);\r\n    watcher.update();\r\n    return watcher;\r\n}\r\n\n// CONCATENATED MODULE: ./src/unobserve.ts\n\r\n\r\n/**\r\n * Stops all observations for the given variable. Optionally it can travel\r\n * through all descendant observers and unobserve them as well.\r\n *\r\n * @param input The possibly observed object.\r\n * @param deep If all descendant observers should be unobserved.\r\n * @param destroy If the proxy should be destroyed, making it unusable.\r\n * @returns The reference to the value passed to this function.\r\n */\r\nfunction unobserve(input, deep, destroy) {\r\n    if (deep === void 0) { deep = false; }\r\n    if (destroy === void 0) { destroy = true; }\r\n    if (isObserved(input)) {\r\n        var obs = input[PROPERTY];\r\n        delete input[PROPERTY];\r\n        obs.destroy(input, deep, destroy);\r\n    }\r\n    return input;\r\n}\r\n\n// CONCATENATED MODULE: ./src/computed.ts\n\r\n/**\r\n * Adds or overrides the given property on the given object so when the property\r\n * is read a watched expression is ran whch generates and returns a value. If\r\n * no dependent variables have changed, then a cached is returned.\r\n *\r\n * @param target The object to add a proeprty to.\r\n * @param prop The name of the property to add.\r\n * @param expr The watched function which should return a value.\r\n * @returns A new instance of Watcher.\r\n */\r\nfunction computed(target, prop, expr) {\r\n    var watcher = watch(expr, { immediate: false, deep: false });\r\n    watcher.dirty = true;\r\n    Object.defineProperty(target, prop, {\r\n        configurable: false,\r\n        enumerable: true,\r\n        get: function () {\r\n            if (watcher.dirty) {\r\n                watcher.update();\r\n            }\r\n            return watcher.result;\r\n        }\r\n    });\r\n    return watcher;\r\n}\r\n\n// CONCATENATED MODULE: ./src/index.ts\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"PROPERTY\", function() { return PROPERTY; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"ARRAY_CHANGES\", function() { return ARRAY_CHANGES; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"ARRAY_ITERATIONS\", function() { return ARRAY_ITERATIONS; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Dependency\", function() { return Dependency_Dependency; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Watcher\", function() { return Watcher_Watcher; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Observer\", function() { return Observer_Observer; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Node\", function() { return Node; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Link\", function() { return Link_Link; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"handler\", function() { return handler; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"watch\", function() { return watch; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"observe\", function() { return observe; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"isObservable\", function() { return isObservable; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"isObserved\", function() { return isObserved; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"unobserve\", function() { return unobserve; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"computed\", function() { return computed; });\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// scrute.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 583ce262d2bc2d4b6350","\nimport { PROPERTY, ARRAY_CHANGES, ARRAY_ITERATIONS } from './Constants';\nimport { Dependency } from './Dependency';\nimport { Observer } from './Observer';\nimport { Link } from './Link';\nimport { liveWatchers } from './Watcher';\nimport { observe, isObservable, isObserved } from './observe';\n\n\n\n/**\n * The handler to pass to the Proxy constructor.\n */\nexport const handler =\n{\n\n  /**\n   * Intercepts the property getting so any watch functions can gather its list\n   * of dependencies.\n   */\n  get (target: any, prop: PropertyKey, _reciever: any)\n  {\n    let val: any = target[ prop ];\n\n    if (prop === PROPERTY)\n    {\n      return val;\n    }\n\n    const obs: Observer = target[ PROPERTY ] as Observer;\n\n    if (typeof val === 'function')\n    {\n      if (target instanceof Array)\n      {\n        if (prop in ARRAY_CHANGES)\n        {\n          return handleArrayChange( target, val, obs );\n        }\n\n        if (prop in ARRAY_ITERATIONS)\n        {\n          return handleArrayIteration( target, val, obs );\n        }\n      }\n\n      return val;\n    }\n\n    return handleWatching( target, prop, val, obs );\n  },\n\n  /**\n   * Intercepts the property setting so all dependent watchers are notified,\n   */\n  set (target: any, prop: PropertyKey, value: any, _reciever: any): boolean\n  {\n    if (value !== target[ prop ])\n    {\n      target[prop] = value;\n\n      const obs: Observer = target[ PROPERTY ] as Observer;\n\n      obs.notify( prop, true );\n    }\n\n    return true;\n  },\n\n  /**\n   * Intercepts the property delete operator so all dependent watchers no longer\n   * listen to changes.\n   */\n  deleteProperty (target: any, prop: PropertyKey): boolean\n  {\n    const obs: Observer = target[ PROPERTY ] as Observer;\n\n    obs.remove( prop );\n\n    return true;\n  }\n\n};\n\n\n/**\n * If a property on an object contains an observable object/array which is not\n * yet being observered - it is replaced with a proxy. The value of the property\n * is returned.\n */\nfunction handleWatching (target: any, prop: PropertyKey, val: any, obs: Observer): any\n{\n  const dep: Dependency = obs.dep( prop );\n\n  liveWatchers.forEach( watcher => Link.create( watcher, dep ) );\n\n  if (isObservable( val ) && !isObserved( val ))\n  {\n    target[ prop ] = val = observe( val, { parent: dep } );\n  }\n\n  return val;\n}\n\n/**\n * Returns a function which ensures when its called that all items and the\n * length of the array is watched by any live watchers.\n */\nfunction handleArrayIteration (target: any[], val: Function, obs: Observer): () => any\n{\n  return function()\n  {\n    const length: number = target.length;\n\n    for (let i = 0; i < length; i++)\n    {\n      handleWatching( target, i, target[ i ], obs );\n    }\n\n    handleWatching( target, 'length', target.length, obs );\n\n    return val.apply( target, arguments );\n  };\n}\n\n/**\n * Returns a function which notifies any watched functions of changes after a\n * mutating array operation is executed.\n */\nfunction handleArrayChange (target: any[], val: Function, obs: Observer): () => any\n{\n  return function ()\n  {\n    const copy = target.slice();\n    const result = val.apply( target, arguments );\n    const max: number = Math.max( copy.length, target.length );\n    let deepNotified: boolean = false;\n\n    for (let i = 0; i < max; i++)\n    {\n      if (copy[i] !== target[i])\n      {\n        deepNotified = deepNotified || obs.notify( i );\n      }\n\n      if (i >= target.length)\n      {\n        obs.remove( i );\n      }\n    }\n\n    if (target.length !== copy.length)\n    {\n      deepNotified = deepNotified || obs.notify( 'length' );\n    }\n\n    if (deepNotified && obs.parent)\n    {\n      obs.parent.notify( true );\n    }\n\n    return result;\n  };\n}\n\n\n// WEBPACK FOOTER //\n// ./src/handler.ts","\nimport { PROPERTY } from './Constants';\nimport { Observer } from './Observer';\nimport { Dependency } from './Dependency';\nimport { handler } from './handler';\n\n\n/**\n * Options that can be passed to the observe function.\n */\nexport interface ObserveOptions\n{\n  parent?: Dependency;\n}\n\n/**\n * Observes the object/array if is not yet observed. An observed object is one\n * that can be used in watch functions and will trigger then when referenced\n * values in the observed object changes.\n *\n * @param input The object/array to observe for changes.\n * @returns The reference to the object/array or the Proxy if it is observable\n *    and has not yet been observed.\n */\nexport function observe <T>(input: T, { parent = null }: ObserveOptions = {}): T\n{\n  if (isObservable(input))\n  {\n    if (!input[PROPERTY])\n    {\n      const proxy = Proxy.revocable( <any>input, handler );\n\n      input = proxy.proxy as T;\n\n      Object.defineProperty( input, PROPERTY, {\n        value: new Observer( proxy.revoke, parent ),\n        writable: false,\n        configurable: true,\n        enumerable: false\n      });\n    }\n  }\n\n  return input;\n}\n\n/**\n * Determines whether the given input can be observed.\n *\n * @param input The input to test.\n */\nexport function isObservable (input: any): boolean\n{\n  return !!(typeof input === 'object' && input !== null);\n}\n\n/**\n * Determines whether the given input is currently being observed.\n *\n * @param input The input to check for observation.\n */\nexport function isObserved (input: any): boolean\n{\n  return !!(typeof input === 'object' && input !== null && input[ PROPERTY ]);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/observe.ts","\nimport { Watcher } from './Watcher'\n\n\n\n/**\n * Options which can be passed to the watch function.\n */\nexport interface WatchOptions\n{\n  /**\n   * If the function should executed as soon as a dependent value changes\n   * (true), or simply mark the returned Watcher instance as dirty (false).\n   */\n  immediate?: boolean;\n\n  /**\n   * If true, not only does the function execute when referenced values change,\n   * but also nested values.\n   */\n  deep?: boolean;\n}\n\n\n/**\n * Given a function to execute, any observed objects/arrays which are referenced\n * in that function are tracked. If they change the given function will execute\n * again and a new list of dependencies is generated. A Watcher instance is\n * returned which can be used to pause, resume, or stop watching for changes.\n *\n * @param expr The function to execute when any referenced observed values change.\n * @param immediate If the function should executed as soon as a dependent value\n *    changes (true), or simply mark the returned Watcher instance as dirty (false).\n * @param deep If true, not only does the function execute when referenced\n *    values change, but also nested values.\n * @returns A new instance of Watcher.\n */\nexport function watch (expr: () => any, { immediate = true, deep = false }: WatchOptions = {}): Watcher\n{\n  const watcher = new Watcher( expr, immediate, deep );\n\n  watcher.update();\n\n  return watcher;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/watch.ts","\nimport { PROPERTY } from './Constants';\nimport { Observer } from './Observer';\nimport { isObserved } from './observe';\n\n\n\n/**\n * Stops all observations for the given variable. Optionally it can travel\n * through all descendant observers and unobserve them as well.\n *\n * @param input The possibly observed object.\n * @param deep If all descendant observers should be unobserved.\n * @param destroy If the proxy should be destroyed, making it unusable.\n * @returns The reference to the value passed to this function.\n */\nexport function unobserve <T>(input: T, deep: boolean = false, destroy: boolean = true): T\n{\n  if (isObserved( input ))\n  {\n    const obs: Observer = input[ PROPERTY ] as Observer;\n\n    delete input[ PROPERTY ];\n\n    obs.destroy( input, deep, destroy );\n  }\n\n  return input;\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/unobserve.ts","\nimport { Watcher, WatchExpression } from './Watcher';\nimport { watch } from './watch';\n\n\n\n/**\n * Adds or overrides the given property on the given object so when the property\n * is read a watched expression is ran whch generates and returns a value. If\n * no dependent variables have changed, then a cached is returned.\n *\n * @param target The object to add a proeprty to.\n * @param prop The name of the property to add.\n * @param expr The watched function which should return a value.\n * @returns A new instance of Watcher.\n */\nexport function computed (target: any, prop: PropertyKey, expr: WatchExpression): Watcher\n{\n  const watcher: Watcher = watch( expr, { immediate: false, deep: false } );\n\n  watcher.dirty = true;\n\n  Object.defineProperty( target, prop, {\n    configurable: false,\n    enumerable: true,\n    get () {\n      if (watcher.dirty) {\n        watcher.update();\n      }\n      return watcher.result;\n    }\n  });\n\n  return watcher;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/computed.ts","\n/**\n * The hidden property which stores the reference to the Observer for an object.\n */\nexport const PROPERTY = '$obs';\n\n/**\n * This is a map of array functions which modify the contents of an array. When\n * this happens the observed array is checked for referential and length changes.\n */\nexport const ARRAY_CHANGES = {\n  'pop': 1,\n  'push': 1,\n  'shift': 1,\n  'unshift': 1,\n  'reverse': 1,\n  'splice': 1,\n  'sort': 1,\n};\n\n/**\n * This is a map of array functions which can return different results when the\n * array is modified with the above functions. When these functions are called\n * the watch function observes all items in the array and it's length.\n */\nexport const ARRAY_ITERATIONS = {\n  'concat': 1,\n  'every': 1,\n  'fill': 1,\n  'filter': 1,\n  'find': 1,\n  'findIndex': 1,\n  'forEach': 1,\n  'includes': 1,\n  'indexOf': 1,\n  'join': 1,\n  'lastIndexOf': 1,\n  'map': 1,\n  'reduce': 1,\n  'reduceRight': 1,\n  'slice': 1,\n  'some': 1,\n};\n\n\n// WEBPACK FOOTER //\n// ./src/Constants.ts","\n\n/**\n * A node in a doubly-linked list. The functions in this class are mostly\n * intended for use by the head node. A default head node points to itself and\n * has a null value. A node always has a next or previous node reference.\n */\nexport class Node<T>\n{\n\n  public next: Node<T>;\n  public prev: Node<T>;\n  public value: T;\n\n  /**\n   * Creates a new node given a value.\n   *\n   * @param value The value for the node.\n   */\n  public constructor (value: T)\n  {\n    this.value = value;\n    this.next = this.prev = this;\n  }\n\n  /**\n   * Iterates over the nodes in the linked list and returns the number of nodes\n   * in the list.\n   *\n   * @param iterator The function to call with the value of the node, the\n   *    reference to the node (useful for removing the value from the list),\n   *    and the index of the value in the list starting at the next node.\n   */\n  public forEach (iterator: (value: T, node: Node<T>, index: number) => any): number\n  {\n    let curr: Node<T> = this.next;\n    let index: number = 0;\n\n    while (curr !== this)\n    {\n      const next: Node<T> = curr.next;\n\n      iterator( curr.value, curr, index );\n\n      curr = next;\n      index++;\n    }\n\n    return index;\n  }\n\n  /**\n   * Inserts this Node after the given node.\n   *\n   * @param prev The node to insert this Node after.\n   */\n  public insertAfter (prev: Node<T>): void\n  {\n    this.next = prev.next;\n    this.prev = prev;\n    this.prev.next = this.next.prev = this;\n  }\n\n  /**\n   * If this is the head of a list, this function adds a node to the very end\n   * of the list. This is also equivalent to adding the given node directly\n   * before this node.\n   *\n   * @param last The node to insert at the end of the list / before this node.\n   */\n  public push (last: Node<T>): void\n  {\n    last.insertAfter(this.prev);\n  }\n\n  /**\n   * If this Node is in a list, it removes itself from the list.\n   */\n  public remove (): void\n  {\n    if (!this.isEmpty())\n    {\n      this.next.prev = this.prev;\n      this.prev.next = this.next;\n      this.prev = this.next = this;\n    }\n  }\n\n  /**\n   * Returns whether the list this node is in is empty.\n   */\n  public isEmpty (): boolean\n  {\n    return this.next === this;\n  }\n\n  /**\n   * Returns a new node for the head of the list.\n   */\n  public static head<T>(): Node<T>\n  {\n    return new Node(null);\n  }\n\n}\n\n\n// WEBPACK FOOTER //\n// ./src/Node.ts","\nimport { Link } from './Link';\nimport { Node } from './Node';\nimport { Observer } from './Observer';\n\n\n\n/**\n * A map of dependencies keyed by the property name.\n */\nexport type DependencyMap = { [prop: string]: Dependency };\n\n\n/**\n * A dependency is a property of an object or an item in an array.\n */\nexport class Dependency\n{\n\n  public links: Node<Link>;\n  public observer: Observer;\n\n  /**\n   * Creates a new Dependency.\n   *\n   * @param observer The observer for the object.\n   */\n  public constructor (observer: Observer)\n  {\n    this.observer = observer;\n    this.links = Node.head();\n  }\n\n  /**\n   * Notifies all observing watchers that this dependency has changed. If any\n   * of the watchers are watching for deep (sub) changes the parent dependency\n   * is notified.\n   *\n   * @param notifyParent If a deep watcher is listening on this dependency,\n   *    should we notify the parent of the observer?\n   * @returns True if a deep watcher was notified.\n   */\n  public notify (notifyParent: boolean = false): boolean\n  {\n    let deep: boolean = false;\n\n    this.links.forEach(link =>\n    {\n      link.watcher.notify()\n\n      deep = deep || link.watcher.deep;\n    });\n\n    if (notifyParent && deep && this.observer.parent)\n    {\n      this.observer.parent.notify( notifyParent );\n    }\n\n    return deep;\n  }\n\n  /**\n   * Destroys the depdendency removing it from all watchers.\n   */\n  public destroy (): void\n  {\n    this.links.forEach(link => link.remove());\n  }\n\n}\n\n\n// WEBPACK FOOTER //\n// ./src/Dependency.ts","\nimport { Node } from './Node'\nimport { Link } from './Link'\n\n\n\n/**\n * An array of watcher functions which are currently executing.\n */\nexport const liveWatchers: Watcher[] = [];\n\n/**\n * The loose definition for a watched function. It could return a value, or\n * nothing. Any returned value is stored in the Watcher in the result property.\n */\nexport type WatchExpression = () => any;\n\n\n/**\n * A class which holds a user supplied function and list of observed\n * depdendencies it references. When any of those dependencies change a watcher\n * is notified.\n */\nexport class Watcher\n{\n\n  public expression: WatchExpression;\n  public result: any;\n  public onResult: WatchExpression;\n  public dirty: boolean;\n  public immediate: boolean;\n  public deep: boolean;\n  public links: Node<Link>;\n  public paused: boolean;\n  public evaluating: boolean;\n\n  /**\n   * Creates a new Watcher given an expression, if it's immediate, and if the\n   * watches are deep.\n   */\n  public constructor (expression: WatchExpression, immediate: boolean = true, deep: boolean = false)\n  {\n    this.expression = expression;\n    this.immediate = immediate;\n    this.deep = deep;\n    this.dirty = false;\n    this.paused = false;\n    this.evaluating = false;\n    this.links = Node.head();\n  }\n\n  /**\n   * Determines whether the watch function is currently observing anything for\n   * changes.\n   */\n  public isWatching (): boolean\n  {\n    return !this.links.isEmpty();\n  }\n\n  /**\n   * Notifies the watcher that a dependency has changed.\n   */\n  public notify (): void\n  {\n    if (this.evaluating)\n    {\n      return;\n    }\n\n    this.dirty = true;\n\n    if (this.immediate)\n    {\n      this.update();\n    }\n  }\n\n  /**\n   * Executes the function and gathers a new list of dependencies.\n   */\n  public update (): void\n  {\n    this.evaluating = true;\n\n    this.off();\n\n    liveWatchers.push(this);\n\n    try\n    {\n      this.result = this.expression();\n    }\n    finally\n    {\n      liveWatchers.pop();\n\n      this.dirty = false;\n\n      if (this.onResult)\n      {\n        try\n        {\n          this.onResult();\n        }\n        finally\n        {\n          this.evaluating = false;\n        }\n      }\n\n      this.evaluating = false;\n    }\n  }\n\n  /**\n   * Stops watching for changes.\n   */\n  public off (): void\n  {\n    this.links.forEach(link => link.remove());\n  }\n\n  /**\n   * Stops watching for changes and marks the watcher as paused.\n   */\n  public pause (): void\n  {\n    if (!this.paused)\n    {\n      this.off();\n      this.paused = true;\n    }\n  }\n\n  /**\n   * Resumes watching for changes if the watcher was paused.\n   */\n  public resume (): void\n  {\n    if (this.paused)\n    {\n      this.update();\n      this.paused = false;\n    }\n  }\n\n}\n\n\n// WEBPACK FOOTER //\n// ./src/Watcher.ts","\nimport { Node } from './Node';\nimport { Watcher } from './Watcher';\nimport { Dependency } from './Dependency';\n\n\n\n/**\n * A relationship between a Watcher and Dependency which stores both links so\n * the lists stored in the watcher and dependency can both be removed from\n * instantly.\n */\nexport class Link\n{\n\n  public watcherNode: Node<Link>;\n  public watcher: Watcher;\n\n  public dependencyNode: Node<Link>;\n  public dependency: Dependency;\n\n  /**\n   * Creates a new Link given the Watcher and Dependency.\n   */\n  public constructor (watcher: Watcher, dependency: Dependency)\n  {\n    this.watcher = watcher;\n    this.dependency = dependency;\n    this.watcherNode = new Node( this );\n    this.dependencyNode = new Node( this );\n  }\n\n  /**\n   * Removes the relationship between the Watcher and Dependency.\n   */\n  public remove (): void\n  {\n    this.watcherNode.remove();\n    this.dependencyNode.remove();\n  }\n\n  /**\n   * Creates a link between the given Watcher and Dependency. If a link already\n   * exists, then this function has no effect. If a link does not exist, one is\n   * created and added to both the dependency and watcher lists. A link\n   * reference is always returned.\n   */\n  public static create (watcher: Watcher, dependency: Dependency): Link\n  {\n    let existing: Link = null;\n\n    dependency.links.forEach(link => existing = (link.watcher === watcher ? link : existing));\n\n    if (!existing)\n    {\n      existing = new Link( watcher, dependency );\n\n      dependency.links.push( existing.dependencyNode );\n\n      watcher.links.push( existing.watcherNode );\n    }\n\n    return existing;\n  }\n\n}\n\n\n// WEBPACK FOOTER //\n// ./src/Link.ts","\nimport { PROPERTY } from './Constants';\nimport { isObserved } from './observe';\nimport { Dependency, DependencyMap } from './Dependency';\n\n\n\ntype Key = string | number;\n\n\n/**\n * An observer is for an object/array and keeps track of all watched properties.\n * If the observer belongs to a sub-object on an observed object then it has a\n * parent. This parent reference is needed for deeply watched objects.\n */\nexport class Observer\n{\n\n  public parent: Dependency | null;\n  public deps: DependencyMap;\n  public revoke: () => any;\n\n  /**\n   * Creates a new Observer.\n   *\n   * @param parent An optional parent dependency.\n   */\n  public constructor (revoke: () => any, parent: Dependency | null = null)\n  {\n    this.revoke = revoke;\n    this.parent = parent;\n    this.deps = Object.create(null);\n  }\n\n  /**\n   * Returns a Dependency for the given property and creates it if it doesn't\n   * exist already.\n   *\n   * @param prop The name of the property or the index of the array element.\n   */\n  public dep (prop: PropertyKey): Dependency\n  {\n    let dep: Dependency = this.deps[ prop as Key ];\n\n    if (!dep)\n    {\n      this.deps[ prop as Key ] = dep = new Dependency( this );\n    }\n\n    return dep;\n  }\n\n  /**\n   * If the given property or array element is being watched, all watchers will\n   * be notified.\n   *\n   * @param prop The name of the property or the index of the array element to\n   *    notify of changes.\n   * @param notifyParent If a deep watcher is listening on this dependency,\n   *    should we notify the parent of the observer?\n   * @returns True if a deep watcher was notified.\n   */\n  public notify (prop: PropertyKey, notifyParent: boolean = false): boolean\n  {\n    const deps: DependencyMap = this.deps;\n\n    if (prop in deps)\n    {\n      return deps[ prop as Key ].notify( notifyParent );\n    }\n    else if (notifyParent && this.parent)\n    {\n      this.parent.notify( notifyParent );\n    }\n\n    return false;\n  }\n\n  /**\n   * Removes the given property or array element so it's no longer observed for\n   * changes.\n   *\n   * @param prop The name of the property or the index of the array element to\n   *    cease watching on.\n   */\n  public remove (prop: PropertyKey): void\n  {\n    const deps: DependencyMap = this.deps;\n\n    if (prop in deps)\n    {\n      deps[ prop as Key ].destroy();\n\n      delete deps[ prop as Key ];\n    }\n  }\n\n  /**\n   * Destroys this observer by destroying all dependents.\n   *\n   * @param target The object which holds this observer.\n   * @param deep If any descendant objects should be destroyed as well.\n   * @param revoke If the proxy should be revoked, making the object unusable.\n   */\n  public destroy (target: any, deep: boolean = false, revoke: boolean = true): void\n  {\n    const deps: DependencyMap = this.deps;\n\n    for (let prop in deps)\n    {\n      deps[ prop ].destroy();\n\n      delete deps[ prop ];\n\n      if (deep)\n      {\n        const value: any = target[ prop ];\n\n        if (isObserved( value ))\n        {\n          const obs = value[ PROPERTY ] as Observer;\n\n          obs.destroy( value, deep, revoke );\n        }\n      }\n    }\n\n    if (revoke)\n    {\n      this.revoke();\n    }\n  }\n\n}\n\n\n// WEBPACK FOOTER //\n// ./src/Observer.ts","\nimport { PROPERTY, ARRAY_CHANGES, ARRAY_ITERATIONS } from './Constants';\n\nimport { Dependency, DependencyMap } from './Dependency';\nimport { Watcher, WatchExpression } from './Watcher';\nimport { Observer } from './Observer';\nimport { Node } from './Node';\nimport { Link } from './Link';\n\nimport { handler } from './handler';\nimport { watch, WatchOptions } from './watch';\nimport { observe, isObservable, isObserved, ObserveOptions } from './observe';\nimport { unobserve } from './unobserve';\nimport { computed } from './computed';\n\n\n\nexport {\n  PROPERTY, ARRAY_CHANGES, ARRAY_ITERATIONS,\n  Dependency, DependencyMap,\n  Watcher, WatchExpression,\n  Observer,\n  Node,\n  Link,\n  handler,\n  watch, WatchOptions,\n  observe, isObservable, isObserved, ObserveOptions,\n  unobserve,\n  computed\n};\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts"],"sourceRoot":""}